/**
 * @file
 * @brief Contains the implementation of the TPZRefPattern methods. 
 */
/* Generated by Together */

#include "TPZRefPattern.h"
#include "pztrnsform.h"
#include "pzreal.h"
#include "pzgmesh.h"
#include "pzquad.h"
#include "pzvec.h"
#include "pzeltype.h"
#include "tpzpermutation.h"
#include "pzgeoel.h"
#include "pzlog.h"
#include "TPZVTKGeoMesh.h"

#include <set>

#include <fstream>
#include <sstream>

using namespace std;

#ifdef LOG4CXX
static LoggerPtr logger(Logger::getLogger("pz.mesh.tpzrefpattern"));
#endif

std::map<MElementType, std::list<TPZRefPattern::TPZRefPatternPermute> > TPZRefPattern::fPermutations;

TPZRefPattern::TPZRefPattern() : fSideRefPattern(0), fId(nonInitializedId), fName("noname")
{
	
}

TPZRefPattern::TPZRefPattern(std::istream &file) : fSideRefPattern(0), fId(nonInitializedId), fName("noname")
{
	ImportPattern(file);	
}

TPZRefPattern::TPZRefPattern(const std::string &file ) : fSideRefPattern(0), fId(nonInitializedId), fName("noname")
{
	ifstream input(file.c_str());
	ImportPattern(input);
	
	/*
	 BuildName();
	 ofstream output(file.c_str());
	 ExportPattern(output);
	 */
}

TPZRefPattern::TPZRefPattern(TPZGeoMesh &RefPatternMesh): fRefPatternMesh(RefPatternMesh), fSideRefPattern(0), fId(nonInitializedId), fName("noname")
{
	fNSubEl = RefPatternMesh.NElements() - 1;
	
	SetRefPatternMeshToMasterDomain();
	
	ComputeTransforms();/**calcula as transformacoes entre filhos e pai*/
	ComputePartition();/**efetua a particao do elemento pai de acordo com os lados dos sub-elementos*/
	GenerateSideRefPatterns();
}

TPZRefPattern::TPZRefPattern(const TPZRefPattern &copy) : fRefPatternMesh(copy.fRefPatternMesh), fSideRefPattern(copy.fSideRefPattern), fId(nonInitializedId), fName("noname")
{
	fName = copy.fName;
	fNSubEl = copy.fNSubEl;
	ComputeTransforms();/**calcula as transformacoes entre filhos e pai*/
	ComputePartition();/**efetua a particao do elemento pai de acordo com os lados dos sub-elementos*/
	GenerateSideRefPatterns();
}

TPZRefPattern::TPZRefPattern(const TPZRefPattern &copy, const TPZPermutation &permute) : fRefPatternMesh(copy.fRefPatternMesh), fId(nonInitializedId), fName("noname")
{
	fNSubEl = copy.fNSubEl;
	this->PermuteMesh(permute);
	
	SetRefPatternMeshToMasterDomain();
	
	ComputeTransforms();/**calcula as transformacoes entre filhos e pai*/
	ComputePartition();/**efetua a particao do elemento pai de acordo com os lados dos sub-elementos*/
	GenerateSideRefPatterns();
}

int TPZRefPattern::operator==(const TPZAutoPointer<TPZRefPattern> compare) const
{
	if(fRefPatternMesh.NNodes() != compare->fRefPatternMesh.NNodes() || fRefPatternMesh.NElements() != compare->fRefPatternMesh.NElements())
	{
		return 0;
	}
	TPZGeoEl *father = fRefPatternMesh.ElementVec()[0];
	TPZGeoEl *compfather = compare->fRefPatternMesh.ElementVec()[0];
	if(father->Type() != compfather->Type())
	{
		return 0;
	}
	
	int nnodes = fRefPatternMesh.NNodes();
	int dim = father->Dimension();
	std::map<int,int> nodemap;
	
	REAL Tol;
	ZeroTolerance(Tol);
	int in;
	for(in = 0; in < nnodes; in++)
	{
		TPZManVector<REAL,3> coord(3,0.), coordcompare(3,0.);
		TPZManVector<REAL,3> elparam(dim,0.), compareparam(dim,0.);
		
		int i;
		for(i = 0; i < 3; i++)
		{
			coord[i] = fRefPatternMesh.NodeVec()[in].Coord(i);
		}
		
		father->ComputeXInverse(coord,elparam,Tol);
		
//		REAL Tol;
//		ZeroTolerance(Tol);

		TPZManVector<REAL> diff(nnodes,0.);
		int jn;
		for(jn = 0; jn < nnodes; jn++)
		{
			int j;
			for(j = 0; j < 3; j++)
			{
				coordcompare[j] = compare->fRefPatternMesh.NodeVec()[jn].Coord(j);
			}
			
			compfather->ComputeXInverse(coordcompare,compareparam,Tol);
			
			for(j=0 ; j<dim; j++)
			{
				diff[jn] += (elparam[j]-compareparam[j])*(elparam[j]-compareparam[j]);
			}
			
			diff[jn] = sqrt(diff[jn]);
			if(diff[jn] < 1.e-8)
			{
				nodemap[in] = jn;
				break;
			}
		}
		
		if(jn == nnodes)
		{
			return 0;
		}
	}
	
	int nelem = fRefPatternMesh.NElements();
	std::map<int,int> elementmap;
	
	int iel;
	for(iel = 0; iel < nelem; iel++)
	{
		std::set<int> nodeset;
		TPZGeoEl *igel = fRefPatternMesh.ElementVec()[iel];
		int nnode = igel->NNodes();
		
		int in;
	  	for(in = 0; in < nnode; in++)
		{
			nodeset.insert(nodemap[igel->NodeIndex(in)]);
		}
		
		int jel;
		for(jel = 0; jel < nelem; jel++)
		{
			if(elementmap.find(jel) != elementmap.end())
			{
				continue;
			}
			std::set<int> compnodeset;
			TPZGeoEl *jgel = compare->fRefPatternMesh.ElementVec()[jel];
			int jnnode = jgel->NNodes();
			
			int jn;
			if(jnnode != nnode)
			{
				continue;
			}
			
			for(jn = 0; jn < jnnode; jn++)
			{
				compnodeset.insert(jgel->NodeIndex(jn));
			}
			
			if(nodeset == compnodeset)
			{
				elementmap[jel] = iel;
				break;
			}
		}
		
		if(jel == nelem)
		{
			return 0;
		}
	}
	
	return 1;
}

/**
 * @brief Destructor of the object
 */
TPZRefPattern::~TPZRefPattern()
{
    int64_t nel = fRefPatternMesh.NElements();
    for (int64_t el=0; el<nel; el++) {
        fRefPatternMesh.Element(el)->SetFather((int64_t)-1);
    }
}



void TPZRefPattern::BuildName()
{
	fName = TPZRefPatternTools::BuildRefPatternModelName(*this);
}

int TPZRefPattern::ClassId() const {
    return Hash("TPZRefPattern");
}

void TPZRefPattern::Read(TPZStream& buf, void* context) { //ok
    fRefPatternMesh.Read(buf, context);
    buf.Read(fSideRefPattern);
    buf.Read(fPermutedRefPatterns);
    buf.Read(&fNSubEl);
    buf.Read(&fId);
    fFatherSides.Read(buf, context);
    fTransforms.Read(buf, context);
    buf.Read(&fName);
}

void TPZRefPattern::Write(TPZStream& buf, int withclassid) const { //ok
    fRefPatternMesh.Write(buf, withclassid);
    buf.Write(fSideRefPattern);
    buf.Write(fPermutedRefPatterns);
    buf.Write(&fNSubEl);
    buf.Write(&fId);
    fFatherSides.Write(buf, withclassid);
    fTransforms.Write(buf, withclassid);
    buf.Write(&fName);

}

int TPZRefPattern::FatherSide(int side, int sub)
{
	int nsides = fRefPatternMesh.ElementVec()[sub+1]->NSides();
	int nsubs = NSubElements();
	if(side<0 || side>nsides ||  sub <0 ||  sub >nsubs)
	{
		PZError << "TPZRefPattern::FatherSide arguments wrong argument\n";
		PZError << "side = " << side << " sub = " << sub;
		return -1;
	}
	int pos = fTransforms.fInitSonSides[sub];
	
	return ( fTransforms.fFatherSide[pos+side]  );
}

void TPZRefPattern::SideSubElement(int sidein, int position, int & sub, int & sideout)
{
	if(sidein<0 || sidein>Element(0)->NSides())
	{
		PZError << "TPZRefPattern::SideSubElement null side, side = " << sidein << endl;
	}
	
	int insd = fFatherSides.fInitSide[sidein];
	int insd2 = fFatherSides.fInitSide[sidein+1];
	
	if(position < 0 || position > (insd2-insd))//subs2-subsd com numero de sub's do lado
	{
		PZError << "TPZRefPattern::SideSubElement wrong position, position = " << position << endl;
		sub = sideout = -1;
		return;
	}
	//a ordem codeterminada pela particao dos lados do pai, couma ordem fixa
	sub = fFatherSides.fPartitionSubSide[insd].Element(&fRefPatternMesh)->Id()-1;//id contemplado como filho
	sideout = fFatherSides.fPartitionSubSide[insd].Side();
}

TPZTransform<> TPZRefPattern::Transform(int side, int sub)
{
	int nsides = Element(sub+1)->NSides();
	int nsubs = NSubElements();
	if(side<0 || side>nsides ||  sub <0 ||  sub >nsubs){
		PZError << "TPZRefPattern::Transform wrong arguments\n";
		PZError << "side = " << side << " sub = " << sub;
		return TPZTransform<>(0);
	}
	int pos = fTransforms.fInitSonSides[sub];
	return ( fTransforms.fSideTransform[pos+side]  );
}

void TPZRefPattern::SideNodes(int side, TPZVec<int> &vecnodes)
{
	/**side eh um lado do pai, eh preciso achar todos os nao internos ao lado*/
	TPZGeoEl *father = Element(0);
	int nsdfat = father->NSides();
	int nnod = father->NNodes();
	if(side<0 || side>=nsdfat)
	{
		PZError << "TPZRefPattern::SideNodes wrong side, side = " << side << endl;
		vecnodes.Resize(0);
		return;
	}
	if (side < nnod)
	{
		vecnodes.Resize(1);
		vecnodes[0] = Element(0)->NodeIndex(side);
		return ;
	}
	//Aparentemente a estrutura nao contempla os nos...
	side -= nnod;
	
#ifdef HUGE_DEBUG
	if (gDebug == 2)
	{
		cout << "************" << endl;
		cout << fFatherSides.fInitSide << endl;
		cout << "************" << endl;
		cout << fFatherSides.fNSubSideFather << endl;
		cout << "************" << endl;
		
		int nss = fFatherSides.fPartitionSubSide.NElements()-1;
		for (int i =0; i<nss ;i++)
		{
			cout << "\nsubelement " << i << endl;
			cout << "side " << fFatherSides.fPartitionSubSide[i].Side() << endl;
			if (fFatherSides.fPartitionSubSide[i].Element())
			{
				fFatherSides.fPartitionSubSide[i].Element()->Print(cout);
			}
			else
			{
				cout <<  "No associated element " << endl;	
			}
		}
	}
#endif
	
	int pos = fFatherSides.fInitSide[side];
	int pos2 = fFatherSides.fInitSide[side+1];
	vecnodes.Resize(pos2-pos);/**o numero de nao no lado comenor que isto*/
	int count = 0;
	for(int par=pos;par<pos2;par++)/**intervalo do lado side*/
	{
		TPZGeoElSide subs = TPZGeoElSide(fFatherSides.fPartitionSubSide[par], &fRefPatternMesh);//[pos];
		if(!subs.Element())
		{
			PZError << "TPZRefPattern::NSideSubElements puncture in the partition\n";
			vecnodes.Resize(0);
			return;
		}
		//    subs.Element()->Print(cout);
		int sd = subs.Side();
		if(sd < subs.Element()->NNodes())
		{
			TPZGeoEl *el = subs.Element();
			int node = el->NodeIndex(sd);
			vecnodes[count] = node;
			count++;
		}
	}
	vecnodes.Resize(count);
}

int TPZRefPattern::NSideNodes(int side)
{
	int nsdfat = Element(0)->NSides();
	if(side<0 || side>nsdfat)
	{
		PZError << "TPZRefPattern::NSideNodes wrong side, side = " << side << endl;
		return -1;
	}
	TPZManVector<int,10> vec;
	SideNodes(side,vec);
	
	return vec.NElements();
}

int TPZRefPattern::NNodes()
{
	return ( fRefPatternMesh.NodeVec().NElements() );
}

int TPZRefPattern::NSubElements()
{
	return fNSubEl;
}

void TPZRefPattern::NSideSubElements()
{
	/**procura-se o numero de sub-elementos da particao, isto nao eh igual ao numero de elementos da particao*/
	/**side eh um lado do pai, eh preciso achar o numero de sub-elementos ligados a este lado*/
	TPZGeoEl *father = Element(0);
	int nsdfat = father->NSides();
	int nnod = father->NNodes();
	fFatherSides.fNSubSideFather.Resize(nsdfat);
	for(int side = 0; side < nsdfat; side++)//percorre-se os lados do pai
	{
		if(side<nnod)/**os cantos nao fazem parte da particao*/
		{
			fFatherSides.fNSubSideFather[side] = 1;
			continue;
		}
		//arestas, faces e interior: side > nnod
		//tomo todos os elemento distintos da particao do lado
		int sidepos = side-nnod;
		int pos = fFatherSides.fInitSide[sidepos];
		int pos2 = fFatherSides.fInitSide[sidepos+1];
		int size = pos2-pos;
		
		//    TPZVec<int> subs(size,0);// tamanho mcoimo
		//    for(p=pos;p<pos2;p++) subs[p-pos] = fFatherSides.fPartitionSubSide[p].Element()->Id();// todos positivos > 0
		//    for(int i=0;i<size;i++) for(int j=i+1;j<size;j++) if(subs[j]==subs[i]) subs[j] = 0;// anulando os repetidos
		//    int count = 0;
		//    for(int k=0;k<size;k++) if(subs[k]) count++;
		//    fFatherSides.fNSubSideFather[side] = count;
		
		fFatherSides.fNSubSideFather[side] = size;
	}
}

int TPZRefPattern::NSideSubElements(int side)
{
	if(side<0 || side>Element(0)->NSides()){
		PZError << "TPZRefPattern::NSideSubElement null side, side = " << side << endl;
		return -1;/**danou-se*/
	}
	//  cout << "NSideSubElements " <<  fFatherSides.fNSubSideFather << endl;
	return (fFatherSides.fNSubSideFather[side]);
}

void TPZRefPattern::MeshPrint()
{
	ofstream out("meshrefpatt.out");
	cout << "\nTPZRefPattern::Print imprime a malha do padrao de refinamento, arquivo de saida: meshrefpatt.out\n";
	fRefPatternMesh.Print(out);
	out.flush();
	out.close();
}

void TPZRefPattern::PrintMore(std::ostream &out)
{
	out << "TPZRefPattern::TPZSideTransform::Print lado do pai associados aos lados dos sub-elementos\n\n";
	int iside,isub;
	//  int nnod = Element(0)->NNodes();
	int nsubs = NSubElements(); // so dava certo pq era igual ao uniforme
	out << "Refinement Pattern named " << fName << endl;
	for(isub=0;isub<nsubs;isub++){
		TPZGeoEl *sub = Element(isub+1);
		int nsides = sub->NSides();
		for(iside=0;iside<nsides;iside++){
			out << "sub/lado = " << isub << "/" << iside << "  Lado do pai = " << FatherSide(iside,isub)  << endl;
		}
	}
	this->fFatherSides.Print(this->fRefPatternMesh,out);
	this->fTransforms.Print(this->fRefPatternMesh,out);
}

void TPZRefPattern::Print(std::ostream &out)
{
	
#ifdef LOG4CXX
	static LoggerPtr logger(Logger::getLogger("pz.mesh.refpattern"));
#endif
	
	// std::ostringstream buf;
	
	int nnewnodes=0;
	//cout << endl;
	out << std::endl;
	out << "======================================================" << std::endl;
	out <<"PRINTING REFINEMENT PATTERN / Name : "<< fName <<  std::endl;
	int nnodes = fRefPatternMesh.NNodes() ;
	out << std::endl;
	out << "Number of nodes: " << nnodes << std::endl ;
	out << "Ref Id: " << fId << endl;
	out << "SideRefPatterns:";	out << fSideRefPattern << endl;
	int nel = fRefPatternMesh.NElements();
	out << "Number of elements: " << nel << std::endl;
	//cout << "Refinement Type: " << fRefineType << endl;
	out << "________________________________________________" << std::endl;
	out << "Element Node Indexes" << std::endl;
	for (int i=0 ; i<nel ; i++){
		if (i==0){
			out << "Master element nodes: "  ;
		}
		else{
			out << "Element: " << i << " Nodes: " ;
		}
		
		for (int k=0 ; k<fRefPatternMesh.ElementVec()[i]->NNodes() ; k++){
			out << fRefPatternMesh.ElementVec()[i]->NodeIndex(k) << "  ";
		}
		out << std::endl;
	}
	out << std::endl;
	out << "Number of new nodes per side ";
	for (int i=0 ; i<1 ; i++){
		//    cout << "Element: " << i << endl;
		for (int j=0 ; j<fRefPatternMesh.ElementVec()[i]->NSides() ; j++){
			if (fRefPatternMesh.ElementVec()[0]->SideDimension(j)==1){
				nnewnodes = NSideNodes(j);
				out << j << ":" << nnewnodes << " ";
			}
		}
		out << std::endl;
	}
	out << std::endl;
	out << "Nodes coordinates " << std::endl;
	for (int i=0 ; i<nnodes ; i++){
		out << "Node: " << fRefPatternMesh.NodeVec()[i].Id() << " Coordinates:   " << fRefPatternMesh.NodeVec()[i].Coord(0) << "\t\t"  << fRefPatternMesh.NodeVec()[i].Coord(1)  << "\t\t"  << fRefPatternMesh.NodeVec()[i].Coord(2) << std::endl;
	}
	out << std::endl;
	out << std::endl;
	out << std::endl;
	out << std::endl;
	//LOGPZ_DEBUG(logger, buf.str());
}

void TPZRefPattern::ShortPrint(std::ostream &out)
{
	TPZGeoEl *elemento = Element(0);
	int nsides = elemento->NSides();
	TPZVec<int> indices;
	//TPZVec<int> selected(nsides,0);
	out << elemento->TypeName();
	out << " Id " << fId << " Sides " ;
	for (int p=0 ; p<nsides; p++){
        if (elemento->SideDimension(p)==1 && NSideNodes(p))
        {
			out << p << " ";
        }
	}
	
	for(int n = 0; n < fRefPatternMesh.NodeVec().NElements(); n++)
	{
		out << " | ";
		for(int c = 0; c < 3; c++)
		{
			out << fRefPatternMesh.NodeVec()[n].Coord(c) << "   ";
		}
		out << " | ";
	}
}

int TPZRefPattern::SizeOfSubsSides(int ison)
{
	int nsubs = NSubElements();
	if(ison==nsubs) ison--;
	if(ison < 0 || ison > nsubs-1){
		PZError <<  "TPZRefPattern::SizeOfSubsSides filho nao existe, filho = " << ison << endl;
	}
	int count = 0,isub;
	for(isub=0;isub<nsubs;isub++){
		count += Element(isub+1)->NSides();
		if(isub == ison) return count;
	}
	return 0;
}

void TPZRefPattern::DefinitionOfSizePartition()
{
	TPZGeoEl *fat = Element(0);/**elemento pai da divisco*/
	int nsidefat = fat->NSides();
	int nnodes = fat->NNodes();
	int nsides = nsidefat-nnodes;
	fFatherSides.fInitSide.Resize(nsides+1);/**numero de lados do pai + final*/
	int maxsize = 0,sidefat,sf;
	//  int nsubs = NSubElements();
	int size = fTransforms.fFatherSide.NElements();
	fFatherSides.fInitSide[0] = 0;
	for(sf=nnodes;sf<nsidefat;sf++){/**os cantos do pai nao sco particionados*/
		int sd = 0;
		int nsidestot = 0;
		while(sd < size){
			sidefat = fTransforms.fFatherSide[sd];/**peraorre fFatherSide: lado do pai contendo lado de filho*/
			if(sidefat == sf) nsidestot++;/**conta todos os lados repetidos igual a sf*/
			sd++;
		}
		maxsize += nsidestot;/**numero total de lados que particionam os lados do pai (exceto cantos do pai)*/
		fFatherSides.fInitSide[sf-nnodes + 1] = maxsize;/**comeco do praoimo lado do pai*/
	}
	fFatherSides.fPartitionSubSide.Resize(maxsize);
	/**PARA TESTES*/
	//  ofstream out("dimofpartition.out");
	//  out << "Valores de fFatherSides.fInitSide[sd]\n\n";
	//  for(int sd=0;sd<nsides;sd++){
	//    out << "sd : fInitSide[sd] = " << sd << " : " << fFatherSides.fInitSide[sd] << endl;
	//  }
	//  out << "Tamanho de fPartitionSubSide =  " << maxsize;
	//  cout << "\nTPZRefPattern::DefinitionOfSizePartition arquivo da particao: dimofpartition.out\n";
}

int TPZRefPattern::IsFatherNeighbour(TPZGeoElSide fathside, TPZGeoEl *son)
{
	/**se elementos filho e pai tem um lado em comum eles compartilham a vizinhanao*/
	TPZGeoElSide neighbour = fathside.Neighbour();
	while(neighbour.Element() && neighbour.Element()->Id() != fathside.Element()->Id()){
		if(neighbour.Element()->Id() == son->Id()) return 1;/**elementos pai e filho sco vizinhos*/
		neighbour = neighbour.Neighbour();/**peraorre-se a vizinhanao do lado do pai*/
	}
	return 0;//**se nao covizinho entco nenhum sub-elemento compartilha esse lado*/
}

TPZGeoEl *TPZRefPattern::Element(int iel)
{
	int nel = NSubElements()+1;/**filhos mais o pai*/
	if(iel<0 || iel>nel){
		PZError <<  "TPZRefPattern::Element elemento nao existe, elemento de id = " << iel << endl;
	}
	return ( fRefPatternMesh.ElementVec()[iel]  );
}

int TPZRefPattern::IsNotEqual(TPZTransform<> &Told, TPZTransform<> &Tnew)
{
	int64_t nrows = Told.Mult().Rows();
	int64_t naols = Told.Mult().Cols();
	if(Tnew.Mult().Rows()!=nrows || Tnew.Mult().Cols()!=naols) return 1;
	if(Tnew.Sum().Rows()!=Told.Sum().Rows() || Tnew.Sum().Cols()!=Told.Sum().Cols()) return 1;
	int64_t c,r;
	for(r=0;r<nrows;r++){
		for(c=0;c<naols;c++){
			if( fabs(Tnew.Mult()(r,c)-Told.Mult()(r,c)) > 1.e-12 ) return 1;
		}
		if( fabs(Tnew.Sum()(r,0)-Told.Sum()(r,0)) > 1.e-12 ) return 1;
	}
	return 0;
}

TPZAutoPointer<TPZRefPattern> TPZRefPattern::SideRefPattern(int side)
{
	const int id = this->fSideRefPattern[side];
	
	return gRefDBase.FindRefPattern(id);
}

TPZAutoPointer<TPZRefPattern> TPZRefPattern::SideRefPattern(int side, TPZTransform<> &trans)
{
	if(side >= fSideRefPattern.NElements())
	{
		return NULL;
	}
	TPZAutoPointer<TPZRefPattern> sideref = this->SideRefPattern(side);
	TPZAutoPointer<TPZRefPattern> zero;
	if(!sideref)
	{
		return zero;
	}
	else 
	{
		return sideref->FindRefPattern(trans);
	}
}

void TPZRefPattern::CreateNewNodes(TPZGeoEl * gel, TPZVec<int64_t> &newnodeindexes)
{
	int side;
	int nnodes = gel->NCornerNodes();
	int totalnodes = fRefPatternMesh.NNodes();
	newnodeindexes.Resize(totalnodes);
	
	if (gel->HasSubElement()){
		cout << "CreateNewNodes called for an element which is already divided. \n";
		cout.flush();
		return;
		// Este trecho nao teria funcionado mesmo. Nada garante que esta ordem seria
		// respeitada pelo padrao de refinamento
		//    for (side=gel->NCornerNodes();side<gel->NSides();side++){
		//      gel->MidSideNodeIndex(side,index);
		//      newnodeindexes[side-sum] = index;
		//    }
		//    return;
	}
	
	int nsides = gel->NSides();
	//Nao estou mais iterando em i... melhorou??
	for (side = nnodes;side<nsides;side++){
		CreateMidSideNodes(gel,side,newnodeindexes);
	}
}

void TPZRefPattern::CreateMidSideNodes(TPZGeoEl * gel, int side, TPZVec<int64_t> &newnodeindexes)
{
	int i, j, k;
	int64_t index;
	TPZGeoMesh *gmesh = gel->Mesh();
	//SideNodes retorna um vetor com os indices dos nos internos da malha refpatern
	//com ele eu sei quantos nos internos ou, na linguagem antiga , quantos MidSideNodes tem
	TPZManVector<int> sidenodes;
	SideNodes(side,sidenodes);
	TPZGeoElSide gelside(gel,side);
	TPZGeoElSide neighbour(gelside.Neighbour());
	TPZManVector<int64_t> sideindices(0);
	while(neighbour.Element() && neighbour != gelside)
	{
		if(neighbour.HasSubElement() && neighbour.Element()->NSideSubElements(neighbour.Side()) > 1)
		{
			neighbour.Element()->MidSideNodeIndices(neighbour.Side(),sideindices);
			break;
		}
		neighbour = neighbour.Neighbour();
	}
	for (j=0;j<sidenodes.NElements();j++)
	{
		index = sidenodes[j];
		//coordenadas do novo no na malha ref pattern
		TPZManVector<REAL,3> refnodecoord(3,0.);
		TPZManVector<REAL,3> neighbouraoord(3,0.);
        
		for (k=0;k<3;k++)
        {
            double coord = fRefPatternMesh.NodeVec()[index].Coord(k);
            refnodecoord[k] = coord;
        }
        
		//passando para as coordenadas do elemento da malha real...
		TPZManVector<REAL,3> newnodecoord(Element(0)->Dimension(),0.);
        
		//coordenada no espaco do elemento mestre do elemento de
		//referencia da malha refpattern
		REAL Tol;
		ZeroTolerance(Tol);
		Element(0)->ComputeXInverse(refnodecoord,newnodecoord,Tol);
        
		//coordenada espacial do no na malha real
		gel->X(newnodecoord,refnodecoord);
        
		newnodeindexes[index] = -1;
		REAL mindif = -1.;
		int mindifindex = -1;
		//verificar se um vizinho ja criou o no
		for(i=0; i< sideindices.NElements(); i++)
		{
			for(k=0; k<3; k++) neighbouraoord[k] = gmesh->NodeVec()[sideindices[i]].Coord(k);
			REAL dif = 0.;
			for (k=0;k<3;k++)
			{
				dif += (refnodecoord[k] - neighbouraoord[k]) * (refnodecoord[k] - neighbouraoord[k]);
			}
			if(mindifindex < 0. || mindif > dif)
			{
				mindif = dif;
				mindifindex = i;
			}
		}
		if (mindif < 1e-2 && sideindices.NElements() != 0)
		{
			newnodeindexes[index] = sideindices[mindifindex];
		}
		if (mindif >= 1.e-2 && sideindices.NElements() != 0)
		{
#ifdef LOG4CXX
			{
				std::stringstream sout;
				sout << "Incompatible refinement patterns detected\n";
				sout << "Closest node at distance " << mindif << std::endl;
				gel->Print(sout);
				LOGPZ_ERROR(logger,sout.str())
			}
#endif
            std::cout << "Refpattern trying to create midnode but there is an other node closer!\n";
            std::cout << "refnodCoords(" << refnodecoord[0] << "," << refnodecoord[1] << "," << refnodecoord[2] << ")" << std::endl;
            std::cout << "neighbourCoords(" << neighbouraoord[0] << "," << neighbouraoord[1] << "," << neighbouraoord[2] << ")" << std::endl;
			DebugStop();
		}
		if (newnodeindexes[index] == -1)
		{
			//Caso o no nao exista nos vizinhos sera necessario cria-lo...
			int64_t newindex = gmesh->NodeVec().AllocateNewElement();
			gmesh->NodeVec()[newindex].Initialize(refnodecoord,*gmesh);
			newnodeindexes[index] = newindex;
		}
	}
}

string TPZRefPattern::Name()
{
	return fName;
}

void TPZRefPattern::InsertPermuted()
{
	if(!fRefPatternMesh.ElementVec().NElements() || !fRefPatternMesh.ElementVec()[0])
	{
		return;
	}
	
	GenerateSideRefPatterns();
	TPZGeoEl * gel = fRefPatternMesh.ElementVec()[0];
	GeneratePermutations(gel);
	MElementType geltype = gel->Type();
	
	std::list<TPZRefPatternPermute> &permlist = fPermutations[geltype];
	std::list<TPZRefPatternPermute>::iterator it;
	fPermutedRefPatterns.resize(permlist.size());
	
	int64_t counter;
	for(it=permlist.begin(), counter=0; it != permlist.end(); it++,counter++)
	{
		TPZAutoPointer<TPZRefPattern> refp(new TPZRefPattern(*this,(*it).fPermute));
		TPZAutoPointer<TPZRefPattern> found = gRefDBase.FindRefPattern(refp);
		
#ifdef LOG4CXX
        if (logger->isDebugEnabled()) 
		{
			std::stringstream sout;
			sout << "Permutation " << it->fPermute;
			sout << "Created refpattenr refp ";
			refp->Print(sout);
			sout << "found refpattern ";
			if(found) found->Print(sout);
			else sout << "Pattern not found";
			LOGPZ_DEBUG(logger,sout.str())
		}
#endif
		
		if(found)
		{
			fPermutedRefPatterns[counter] = found->Id();
		}
		else
		{
			if(this->NameInitialized())
			{
				refp->BuildName();
			}
			gRefDBase.InsertRefPattern(refp);
		}
	}
}

void TPZRefPattern::GenerateSideRefPatterns()
{
	if(!fRefPatternMesh.ElementVec().NElements())
	{
		return;
	}
	
	TPZGeoEl *gel = fRefPatternMesh.ElementVec()[0];
	
	int nsides = gel->NSides();
	fSideRefPattern.Resize(nsides,-1);
	fSideRefPattern.Fill(-1.);
	
	int thisId = this->Id();
	fSideRefPattern[nsides-1] = thisId;
	
	int is;
	for(is=0; is<nsides-1; is++)
	{
		if(gel->SideDimension(is) == 0)
		{
			continue;
		}
		if(NSideSubElements(is) == 1)
		{
			continue;		
		}
		TPZAutoPointer<TPZRefPattern> sideref(new TPZRefPattern());
		
		BuildSideMesh(is, sideref->fRefPatternMesh);
		
		sideref->SetRefPatternMeshToMasterDomain();
		
		sideref->fNSubEl = sideref->fRefPatternMesh.NElements()-1;
		sideref->ComputeTransforms();/**calcula as transformacoes entre filhos e pai*/
		sideref->ComputePartition();/**efetua a particao do elemento pai de acordo com os lados dos */
		
		TPZAutoPointer<TPZRefPattern> found = gRefDBase.FindRefPattern(sideref);
		
		if(!found.operator ->())
		{			
			if(this->NameInitialized())
			{
				sideref->BuildName();
			}
			sideref->GenerateSideRefPatterns();
			gRefDBase.InsertRefPattern(sideref);
            fSideRefPattern[is] = sideref->Id();
			sideref->InsertPermuted();
		}
		else
		{
			fSideRefPattern[is] = found->Id();
		}
	}
}

TPZAutoPointer<TPZRefPattern> TPZRefPattern::FindRefPattern(TPZTransform<> &trans)
{
	REAL tol = 1.e-6;
	if(!fRefPatternMesh.ElementVec().NElements() || ! fRefPatternMesh.ElementVec()[0]) return 0;
	MElementType type = fRefPatternMesh.ElementVec()[0]->Type();
	
	std::list<TPZRefPatternPermute> &permlist = fPermutations[type];
	std::list<TPZRefPatternPermute>::iterator it;
	for(it = permlist.begin(); it != permlist.end(); it++)
	{
		TPZRefPatternPermute &tmp = (*it);
		if(!tmp.fTransform.CompareTransform(trans, tol))
		{
			TPZAutoPointer<TPZRefPattern> refpPerm = new TPZRefPattern(*this, tmp.fPermute);
			TPZAutoPointer<TPZRefPattern> found = gRefDBase.FindRefPattern(refpPerm);
			
			return found;
		}
	}
	return 0;
}

void TPZRefPattern::InternalNodesIndexes(int side, TPZVec<TPZGeoElSideIndex> &nodeIndexes)
{
	TPZVec<TPZGeoElSide> gelvec;
	int nSubEl = SidePartition(gelvec, side);
	nodeIndexes.Resize(0);
	int count = 0;
	
	for(int el = 0; el < nSubEl; el++)
	{
		if(gelvec[el].Dimension() == 0)
		{
			count++;
			nodeIndexes.Resize(count);
			TPZGeoElSideIndex elSideIndex(gelvec[el]);
			elSideIndex.SetElementIndex(elSideIndex.ElementIndex()-1);
			nodeIndexes[count-1] = elSideIndex;
		}
	}
}

void TPZRefPattern::InternalSidesIndexes(int side, TPZVec<TPZGeoElSideIndex> &sideIndexes)
{
	TPZVec<TPZGeoElSide> gelvec;
	int nSubEl = SidePartition(gelvec, side);
	sideIndexes.Resize(nSubEl);
	
	for(int el = 0; el < nSubEl; el++)
	{
		TPZGeoElSideIndex elSideIndex(gelvec[el]);
		elSideIndex.SetElementIndex(elSideIndex.ElementIndex()-1);
		sideIndexes[el] = elSideIndex;
	}
}

TPZAutoPointer<TPZRefPattern> TPZRefPattern::GetPermutation(int pos)
{
#ifdef PZDEBUG
	if( pos >= (int)fPermutedRefPatterns.size() )
	{
		std::cout << "Position out of range of fPermutedRefPatterns vector in " << __PRETTY_FUNCTION__ << " !\n";
		DebugStop();
	}
#endif
	
	int id = fPermutedRefPatterns[pos];
 	TPZAutoPointer<TPZRefPattern> refp = gRefDBase.FindRefPattern(id);
	
	return refp;
}

//private

void TPZRefPattern::ImportPattern(std::istream &in)
{
	int nnodes, nelems;
	in >> nnodes >> nelems;
	in >> fId >> fName;
	
	fNSubEl = nelems - 1;
	TPZVec<REAL> coord(3);
	fRefPatternMesh.NodeVec().Resize(nnodes);
	
	//criacao dos nohs
	for(int inode = 0; inode < nnodes; inode++)
	{
		in >> coord[0];
		in >> coord[1];
		in >> coord[2];
		fRefPatternMesh.NodeVec()[inode].Initialize(inode,coord,fRefPatternMesh);
	}
	
	TPZGeoEl *father = 0;
	//criacao dos elementos geometricos que definem a particao
	int ntype, nummat, naorners, incid, el;
	for(el=0; el<nelems; el++)//os sub-elementos podem nao ter de uma mesma geometria
	{
		in >> ntype >> nummat;
		MElementType etype = (MElementType) ntype;
		naorners = MElementType_NNodes(etype);
		TPZVec<int64_t> nodes(naorners);
		for(incid = 0; incid < naorners; incid++)
		{
			in >> nodes[incid];
		}
		int64_t index;
		TPZGeoEl *subel = fRefPatternMesh.CreateGeoElement(etype, nodes, nummat, index, 0);
		if(el == 0)
		{
			father = subel;
            fRefPatternMesh.SetDimension(father->Dimension());
		}
		if(el > 0)
		{
			subel->SetFather(father);
			subel->SetFather(father->Index());
		}
	}
	
	SetRefPatternMeshToMasterDomain();
	fRefPatternMesh.BuildConnectivity();//conectividades entre sub-elementos
	GeneratePermutations(father);
    
    if(0)
    {
        std::ofstream verify("refpat.vtk");
        TPZVTKGeoMesh::PrintGMeshVTK(&fRefPatternMesh, verify);
    }
    
	ComputeTransforms();//calcula as transformacoes entre filhos e pai
	ComputePartition();//efetua a particao do elemento pai de acordo com os lados dos sub-elementos
	GenerateSideRefPatterns();
}

void TPZRefPattern::ExportPattern(std::ostream &out)
{
	out << fRefPatternMesh.NNodes() << ' '  << fRefPatternMesh.NElements() << std::endl << std::endl;
	out << fId << ' ' << fName << std::endl << std::endl ;
	
	for (int i = 0; i < fRefPatternMesh.NNodes() ; i++)
	{
		for (int k=0; k<3; k++)
		{
			out << fRefPatternMesh.NodeVec()[i].Coord(k) << ' ';
		}
		out << std::endl;
	}
	
	out << std::endl ;
	
	for (int i = 0; i < fRefPatternMesh.NElements(); i++)
	{
		out << fRefPatternMesh.ElementVec()[i]->Type() << " " << fRefPatternMesh.ElementVec()[i]->NCornerNodes() << " " ;
		for (int k = 0; k < fRefPatternMesh.ElementVec()[i]->NCornerNodes(); k++)
		{
			out << fRefPatternMesh.ElementVec()[i]->NodeIndex(k) << "  " ;
		}
		out << std::endl;
	}
	out << std::endl;
}

void TPZRefPattern::ReadPattern(std::istream &in)
{
    int nnodes, nelems;
	in >> nnodes >> nelems;
	in >> fId >> fName;
	
	fNSubEl = nelems - 1;
	TPZVec<REAL> coord(3);
	fRefPatternMesh.NodeVec().Resize(nnodes);
	
	//criacao dos nohs
	for(int inode = 0; inode < nnodes; inode++)
	{
		in >> coord[0];
		in >> coord[1];
		in >> coord[2];
		fRefPatternMesh.NodeVec()[inode].Initialize(inode,coord,fRefPatternMesh);
	}
	
	TPZGeoEl *father = 0;
	//criacao dos elementos geometricos que definem a particao
	int ntype, nummat, naorners, incid, el;
	for(el=0; el<nelems; el++)//os sub-elementos podem nao ter de uma mesma geometria
	{
		in >> ntype >> nummat;
		MElementType etype = (MElementType) ntype;
		naorners = MElementType_NNodes(etype);
		TPZVec<int64_t> nodes(naorners);
		for(incid = 0; incid < naorners; incid++)
		{
			in >> nodes[incid];
		}
		int64_t index;
		TPZGeoEl *subel = fRefPatternMesh.CreateGeoElement(etype, nodes, nummat, index, 0);
		if(el == 0)
		{
			father = subel;
		}
		if(el > 0)
		{
			subel->SetFather(father);
			subel->SetFather(father->Index());
		}
	}
	
	fRefPatternMesh.BuildConnectivity();//conectividades entre sub-elementos
	GeneratePermutations(father);
	ComputeTransforms();//calcula as transformacoes entre filhos e pai
	ComputePartition();//efetua a particao do elemento pai de acordo com os lados dos sub-elementos
	GenerateSideRefPatterns();
    
	int nperm;
	in >> nperm;
	this->fPermutedRefPatterns.resize(nperm);
	for(int el = 0; el < nperm; el++)
	{
		int ip;
		in >> ip;
		fPermutedRefPatterns[el] = ip;
	}
	
	//TPZGeoEl *father = fRefPatternMesh.ElementVec()[0];
	int nsides = father->NSides();
	fSideRefPattern.Resize(nsides,-1);
	fSideRefPattern[nsides-1] = this->Id();
	for(int is = 0; is < nsides; is++)
	{
		int ip;
		in >> ip;
		fSideRefPattern[is] = ip;
	}
	
#ifdef PZDEBUG
	//TPZRefPatternTools::TransformationTest(this);
#endif
}

void TPZRefPattern::WritePattern(std::ofstream &out)
{
	ExportPattern(out);
	
	int nperm = fPermutedRefPatterns.size();
	out << nperm << ' ';
	for(int el = 0; el < nperm; el++)
	{
		out << fPermutedRefPatterns[el] << ' ';
	}
	out << std::endl;
	
	TPZGeoEl *father = fRefPatternMesh.ElementVec()[0];
	int nsides = father->NSides();
	int is;
	for(is=0; is<nsides; is++)
	{
		out << fSideRefPattern[is] << ' ';
	}
	out << std::endl;
}

int TPZRefPattern::SidePartition(TPZVec<TPZGeoElSide> &gelvec, int side)
{
	int nsides = Element(0)->NSides();/**numero de lados do pai*/
	int nnodes = Element(0)->NNodes();
	if(side<nnodes || side>nsides)
	{
		PZError <<  "TPZRefaPattern::SidePartition side error: side = " << side << endl;
		gelvec.Resize(0);
		return 0;
	}
	side -= Element(0)->NNodes();/**nao inclui cantos*/
	int64_t firstpos = fFatherSides.fInitSide[side];/**posicao inicial da particao do lado*/
	int64_t lastpos = fFatherSides.fInitSide[side+1];/**posicao final da particao do lado*/
	int64_t size = lastpos-firstpos;
	gelvec.Resize(size);/**tamanho: numero de elementos da particao do lado*/
	int64_t pos;
	for(pos = firstpos;pos<lastpos;pos++)
	{
		int64_t pos0 = pos - firstpos;
		gelvec[pos0] = TPZGeoElSide(fFatherSides.fPartitionSubSide[pos], &fRefPatternMesh);
	}
	
	return size;//numero de elementos da particao do lado
}

void TPZRefPattern::SetRefPatternMeshToMasterDomain()
{
	//Levando a fRefPatternMesh para o espaço parametrico do elemento mestre
	int nnodes = fRefPatternMesh.NodeVec().NElements();
	TPZManVector< TPZManVector<REAL,3> ,20> nodecoords_inQSI(nnodes);
	TPZManVector<REAL,3> nodecoords_inX;
	TPZGeoEl * gel = fRefPatternMesh.ElementVec()[0];
	
    
	int dim = gel->Dimension();
	TPZManVector<REAL,3> temp(3,0.);
	REAL Tol;
	ZeroTolerance(Tol);
	
	for(int n = 0; n < nnodes; n++)
	{
		nodecoords_inX.Resize(3,0.);
		fRefPatternMesh.NodeVec()[n].GetCoordinates(nodecoords_inX);
		
		nodecoords_inQSI[n].Resize(dim,0.);
		gel->ComputeXInverse(nodecoords_inX, nodecoords_inQSI[n],Tol);	
	}
	
	TPZVec<REAL> coordQSIprojected(dim,0.);
	for(int n = 0; n < nnodes; n++)
	{
		//garantia de que o ComputeXInverse nao resultou em pontos levemente fora do dominio de referencia!
		gel->ProjectInParametricDomain(nodecoords_inQSI[n], coordQSIprojected);
		
		int c;
		for(c = 0; c < dim; c++)
		{
			double qsi = coordQSIprojected[c];
			fRefPatternMesh.NodeVec()[n].SetCoord(c,qsi);
		}
		for(; c < 3; c++)
		{
			fRefPatternMesh.NodeVec()[n].SetCoord(c,0.);
		}
	}
}

void TPZRefPattern::ComputeTransforms()
{
	/**calcula transformacoes entre lado de filho e lado de pai*/
	TPZGeoEl *fath = Element(0);/**Elemento pai deve ser o primeiro elemento da lista*/
	if(!fath)
	{
		PZError << "TPZRefPattern::ComputePartition Father not exists?!\n";
		DebugStop();
	}
	
	int isub, nsubs = NSubElements();/**total filhos*/
	
	/**preenchendo a estrutura TPZFatherSides*/
	int initside=0,cont=0,side,fatside;
	REAL Tol;
	ZeroTolerance(Tol);
	
	TPZManVector<REAL,3> masscent(3,0.), xpoint(3,0.), fathparam(fath->Dimension(),0.);
	
	fTransforms.fInitSonSides.Resize(nsubs+1);/** +1 para incluir a posicoo final de fSideFather*/
	int size = SizeOfSubsSides(nsubs);
	fTransforms.fFatherSide.Resize(size);//vale -1 quando o lado nao cocontido propriamente*/
	fTransforms.fSideTransform.Resize(size);
	for(isub=0; isub < nsubs; isub++)
	{
		fTransforms.fInitSonSides[isub] = initside;
		TPZGeoEl *son = Element(isub+1);/**o pai nao sabe quem sao os filhos*/
		
		int nsides = son->NSides();
		
		for(side = 0; side < nsides; side++)//cantos + arestas + faces, o interior nao cocompartilhado
		{
			TPZGeoElSide elside (son, side);
			
			son->CenterPoint(side,masscent);/**percorre todos os lados do elemento filho*/
			son->X(masscent,xpoint);
			fath->ComputeXInverse(xpoint,fathparam,Tol);
			
			fatside = fath->WhichSide(fathparam);/**lado do pai contendo o lado do filho*/
			fTransforms.fSideTransform[cont] = son->ComputeParamTrans(fath,fatside,side);
			
			fTransforms.fFatherSide[cont++] = fatside;
			initside++;
		}
	}
	fTransforms.fInitSonSides[isub] = initside;//posicao final em fSideFather
}

void TPZRefPattern::ComputePartition()
{
	int sizeinit = fTransforms.fInitSonSides.NElements()-1;/**igual ao numero de filhos*/
	int init,iside;
	TPZGeoEl *fat = Element(0);/**elemento pai da divisao*/
	DefinitionOfSizePartition();/**calcula o tamanho da particao dos lados do pai e inicializa fInitSide*/
	int sidestot = fFatherSides.fPartitionSubSide.NElements();
	
	/**inicializando o vetor de transformacaos*/
	for(int p=0;p<sidestot;p++) fFatherSides.fPartitionSubSide[p] = TPZGeoElSide();/**zera as entradas*/
	
	/**calcular a particao*/
	for(init = 0; init < sizeinit; init++)/**peraorre os filhos*/
	{
		int initsideson = fTransforms.fInitSonSides[init];/**comeco dos lados do filho*/
		
		TPZGeoEl *son = Element(init+1);/**filho*/
		int nsides = son->NSides();
		for(iside=0;iside<nsides;iside++)/**peraorre-se os lados do filho*/
		{
			int sdf = fTransforms.fFatherSide[initsideson+iside];/**lado do pai associado ao lado do sub-elemento*/
			if(sdf < fat->NNodes())
			{
				continue;/**cantos do pai nao entram na particao do lado*/
			}
			int pos = 0;
			int sdf2 = sdf - fat->NNodes();/**fInitSide nao contempla os cantos, scoa partir de aresta para cima*/
			int initss = fFatherSides.fInitSide[sdf2];/**inicio da particao do lado sdf do pai*/
			
			TPZGeoElSide sonside = TPZGeoElSide(fFatherSides.fPartitionSubSide[initss+pos], &fRefPatternMesh);/**1o sub/lado da particao do lado do pai*/
			TPZGeoElSide empty(sonside);/**copia de sonside*/
			
			int sizept = fFatherSides.fInitSide[sdf2+1]-initss;/**comprimento da faixa do lado*/
			while(empty.Element() && pos < sizept)/**peraorre-se a faixa do lado do pai*/
			{
				pos++;/**procura-se o primeiro lugar desocupado na faixa do lado do pai*/
				empty = TPZGeoElSide(fFatherSides.fPartitionSubSide[initss+pos], &fRefPatternMesh);
			}
			if(pos > sizept-1)/**a faixa toda esta ocupada com sub/lado nao nulo*/
			{
				PZError << "TPZRefPattern::ComputePartition erro de dimensionamento\n";
			}
			fFatherSides.fPartitionSubSide[initss+pos] = TPZGeoElSide(son,iside);
		}
	}
	
	/**conferindo a consistencia da particao*/
	for(int ss=0;ss<sidestot;ss++)
	{
		if(!fFatherSides.fPartitionSubSide[ss].Element(&fRefPatternMesh))
		{
			PZError << "TPZRefPattern::ComputePartition particao inaonsistente";
		}
	}
	
	/**extraindo sub/side quando o side corepetido dentro da particao do lado*/
	int init2;
	sizeinit = fFatherSides.fInitSide.NElements()-1;
	for(iside=0;iside<sizeinit;iside++)/**peraorrendo fInitSide*/
	{
		init = fFatherSides.fInitSide[iside];/**posicao inicial*/
		init2 = fFatherSides.fInitSide[iside+1];/**posicao final*/
		
		for(int sd = init; sd < init2; sd++)/**peraorrendo a particao do lado do pai*/
		{
			TPZGeoElSide gs = TPZGeoElSide(fFatherSides.fPartitionSubSide[sd], &fRefPatternMesh);/**1o sub/side do lado*/
			if(!gs.Element())
			{
				continue;
			}
			for(int sd2 = sd+1; sd2 < init2; sd2++)
			{
				TPZGeoElSide gs2 = TPZGeoElSide(fFatherSides.fPartitionSubSide[sd2], &fRefPatternMesh);/**sub/side sub-seguinte do lado*/
				if(gs2.Element() && gs.Element()->NeighbourExists(gs.Side(),gs2))
				{
					fFatherSides.fPartitionSubSide[sd2] = TPZGeoElSide();/**apagando o sub/side com side repetido*/
				}
			}
		}
	}
	/**tirando os buracos da particao*/
	TPZVec<int> newinit(fFatherSides.fInitSide.NElements());/**capacidade maima*/
	TPZVec<TPZGeoElSideIndex> newpartition(fFatherSides.fPartitionSubSide.NElements());/**capacidade maxima*/
	newinit[0] = 0;
	int count = 0;
	for(iside = 0; iside < sizeinit; iside++)/**peraorrendo fInitSide*/
	{
		init = fFatherSides.fInitSide[iside];/**posicao inicial*/
		init2 = fFatherSides.fInitSide[iside+1];/**posicao final*/
		newinit[iside+1] = newinit[iside];
		for(int sd = init; sd < init2; sd++)/**peraorrendo a particao do lado do pai*/
		{
			TPZGeoElSideIndex gs = fFatherSides.fPartitionSubSide[sd];/**1o sub/side do lado*/
			if(!gs.Element(&fRefPatternMesh))
			{
				continue;
			}
			newinit[iside+1]++;
			newpartition[count++] = gs;
		}
	}
	fFatherSides.fInitSide = newinit;
	fFatherSides.fPartitionSubSide = newpartition;
	NSideSubElements();/**preenche fNSubSideFather com o numero de elementos associados a cada lado do pai*/
}

//struct TPZPartitionFatherSides

void TPZRefPattern::TPZPartitionFatherSides::Print(TPZGeoMesh &gmesh,std::ostream &out)
{
	out << "TPZRefPattern::TPZSideTransform::Print partic dos lados do pai pelos lados dos sub-elementos\n\n";
	int iss,iside;//,count=0;
	TPZGeoEl *father = gmesh.ElementVec()[0];/**elemento pai*/
	int nsfat = father->NSides();
	int nnod = father->NNodes();
	int ntot = nsfat-nnod;
	for(iside=0;iside<ntot;iside++){
		out << "\nLado do elemento pai = " << (iside+nnod) << endl;
		int initsideson = fInitSide[iside];
		int lastsideson = fInitSide[iside+1];
		for(iss=initsideson;iss<lastsideson;iss++){/**peraorre-se os sub/lado da particao*/
			TPZGeoElSideIndex subside = fPartitionSubSide[iss];
			if(!subside.Element(&gmesh)){
				cout <<  "ERRO : Elemento da particao nulo\n ";
				continue;
			}
			out << "Sub id = " << subside.Element(&gmesh)->Id() << "  Lado do sub " << subside.Side()  << endl;
		}
		out << endl;
	}
}

int TPZRefPattern::TPZPartitionFatherSides::ClassId() const {
    return Hash("TPZRefPattern::TPZPartitionFatherSides");
}

void TPZRefPattern::TPZPartitionFatherSides::Read(TPZStream& buf, void* context) { //ok
    buf.Read(fInitSide);
    buf.Read(fPartitionSubSide);
    buf.Read(fNSubSideFather);
}

void TPZRefPattern::TPZPartitionFatherSides::Write(TPZStream& buf, int withclassid) const { //ok
    buf.Write(fInitSide);
    buf.Write(fPartitionSubSide);
    buf.Write(fNSubSideFather);
}

//struct TPZSideTransform

int TPZRefPattern::TPZSideTransform::ClassId() const {
    return Hash("TPZRefPattern::TPZSideTransform");
}

void TPZRefPattern::TPZSideTransform::Read(TPZStream& buf, void* context) { //ok
    buf.Read(fInitSonSides);
    buf.Read(fFatherSide);
    buf.Read(fSideTransform);
}

void TPZRefPattern::TPZSideTransform::Write(TPZStream& buf, int withclassid) const { //ok
    buf.Write(fInitSonSides);
    buf.Write(fFatherSide);
    buf.Write(fSideTransform);
}

void TPZRefPattern::TPZSideTransform::Print(TPZGeoMesh &gmesh, std::ostream &out)
{
	out << "TPZRefPattern::TPZSideTransform::Print transformacoes parametricas\n\n";
	int isub,iside,count=0;
	int nsubs = gmesh.ElementVec().NElements()-1;/**a malha contco um elemento pai e filhos*/
	for(isub=0;isub<nsubs;isub++){
		int elid = gmesh.ElementVec()[isub+1]->Id();
		out << "\n  Sub-element id = " << elid << " ; " << endl << endl;/**a informacoo da malha coestcoica*/
		int nsides = gmesh.ElementVec()[isub+1]->NSides();
		for(iside=0;iside<nsides;iside++){/**peraorre-se os lados de cada filho*/
			out << "> Sub-element/side = " << elid << "/" << iside << "  Side of father = " << fFatherSide[count] << endl;
			fSideTransform[count].Mult().Print("Transformacao  T :",out);
			fSideTransform[count++].Sum().Print("Vetor b : ",out);
		}
		out << endl;
	}
}

void TPZRefPattern::PrintVTK(std::ofstream &file, bool matColor)
{
	//	TPZGeoMesh * gmesh = &(RefPatternMesh());
	//	TPZRefPatternTools::PrintGMeshVTK(gmesh, file, matColor);
	
	TPZGeoMesh * Rgmesh = &(RefPatternMesh());
	TPZGeoMesh * gmesh = new TPZGeoMesh;
	
	int64_t nNodes = Rgmesh->NNodes();
	int64_t nElements = Rgmesh->NElements();
	
	TPZVec < TPZVec <REAL> > NodeCoord(nNodes);
	for(int64_t i = 0; i < nNodes; i++) NodeCoord[i].Resize(3,0.);
	
	//setting nodes coords
	for(int64_t n = 0; n < nNodes; n++)
	{
		NodeCoord[n][0] = Rgmesh->NodeVec()[n].Coord(0);
		NodeCoord[n][1] = Rgmesh->NodeVec()[n].Coord(1);
		NodeCoord[n][2] = Rgmesh->NodeVec()[n].Coord(2);
	}
	
	//initializing gmesh->NodeVec()
	gmesh->NodeVec().Resize(nNodes);
	TPZVec <TPZGeoNode> Node(nNodes);
	for(int64_t n = 0; n < nNodes; n++)
	{
		Node[n].SetNodeId(n);
		Node[n].SetCoord(NodeCoord[n]);
		gmesh->NodeVec()[n] = Node[n]; 
	}
	for(int64_t el = 1; el < nElements; el++)
	{
		TPZGeoEl * Elem = Rgmesh->ElementVec()[el];
		TPZVec<int64_t> cornerindexes(Elem->NNodes());
		int64_t id = Elem->Id();
		for(int n = 0; n < Elem->NNodes(); n++)
		{
			cornerindexes[n] = Elem->NodeIndex(n);
		}
		gmesh->CreateGeoElement(Elem->Type(), cornerindexes, Elem->MaterialId(), id);
	}
	gmesh->BuildConnectivity();
	
	TPZVTKGeoMesh::PrintGMeshVTK(gmesh, file, matColor);
}

//protected

void TPZRefPattern::GeneratePermutations(TPZGeoEl *gel)
{
	if (!gel)
	{
		PZError << "Error at " << __PRETTY_FUNCTION__ << " at line " << __LINE__ << " GeoEl is NULL\n";
		return;
	}
	MElementType geltype = gel->Type();
	
	if(fPermutations.count(geltype))
	{
		return;	
	}
	TPZGeoMesh *gelmesh = gel->Mesh();
	TPZGeoMesh gmesh;
	gmesh.NodeVec().Resize(gel->NNodes());
	
	int in, nnodes = gel->NNodes();
	for(in = 0; in < nnodes; in++)
	{
		gmesh.NodeVec()[in].Initialize(gelmesh->NodeVec()[gel->NodeIndex(in)], gmesh);
	}
	TPZGeoEl *gelp;
	TPZIntPoints *integ = gel->CreateSideIntegrationRule(gel->NSides()-1,3);
	TPZManVector<int64_t,8> nodes(nnodes), nodesperm(nnodes);
	for(in = 0; in < nnodes; in++)
	{
		nodes[in]=in;
	}
	int matid = gel->MaterialId();
	TPZPermutation permute(nnodes);
	TPZTransform<> trans(gel->Dimension());
	TPZRefPatternPermute refpermute;
	
	refpermute.fPermute = permute;
	refpermute.fTransform = trans;
	fPermutations[gel->Type()].push_back(refpermute);
	permute++;
	while(!permute.IsFirst())
	{
		permute.Permute(nodes,nodesperm);
		int64_t index;
		gelp = gmesh.CreateGeoElement(gel->Type(),nodesperm,matid,index,0);
		int dim = gel->Dimension();
		TPZManVector<REAL,3> point(dim,0.);
		REAL w;
		int npoint = integ->NPoints();
		int ip;
		bool valid = true;
		for(ip = 0; ip < npoint; ip++)
		{
			integ->Point(ip,point,w);
			TPZFNMatrix<9> jac(dim,dim),jacinv(dim,dim),axes(3,3);
			REAL detjac,detjac2;
			gelp->Jacobian(point,jac,axes,detjac,jacinv);
			gel->Jacobian(point,jac,axes,detjac2,jacinv);
			if(fabs(fabs(detjac)-fabs(detjac2)) > 1.e-10)
			{
				valid = false;
				break;
			}
		}
		if(valid)
		{
			TPZRefPatternPermute candidate;
			candidate.fPermute = permute;
			candidate.fTransform = gel->ComputeParamTrans(gelp,gel->NSides()-1,gel->NSides()-1);
			fPermutations[gel->Type()].push_back(candidate);
		}
		permute++;
	}
	
	delete integ;
}

void TPZRefPattern::PermuteMesh(const TPZPermutation &permute)
{
	int in;
	TPZGeoEl *father = this->fRefPatternMesh.ElementVec()[0];
	int nn = father->NNodes();
	TPZVec<int> nodes(nn), nodeperm(nn);
	for(in=0; in<nn; in++){
		nodes[in] = father->NodeIndex(in);
	}
	permute.Permute(nodes,nodeperm);
	for(in=0; in<nn; in++){
		father->SetNodeIndex(in, nodeperm[in]);
	}
	fRefPatternMesh.ResetConnectivities();
	fRefPatternMesh.BuildConnectivity();
}

void TPZRefPattern::BuildSideMesh(int side, TPZGeoMesh &SideRefPatternMesh)
{
	if(!fRefPatternMesh.ElementVec().NElements())
	{
		return;		
	}
	TPZGeoEl *gel = fRefPatternMesh.ElementVec()[0];
	TPZStack<int> allsides;
	std::map<int,int> allsidenodes;
	int count =0;
	gel->LowerDimensionSides(side, allsides);
	allsides.Push(side);
	int s;
	for(s=0; s<allsides.NElements(); s++)
	{
		TPZStack<int> sidenodes;
		SideNodes(allsides[s],sidenodes);
		int t;
		for(t=0; t<sidenodes.NElements(); t++)
		{
			if(!allsidenodes.count(sidenodes[t])) allsidenodes[sidenodes[t]] = count++;
		}
	}
	SideRefPatternMesh.NodeVec().Resize(allsidenodes.size());
	std::map<int,int>::iterator it;
	for(it = allsidenodes.begin(); it!= allsidenodes.end(); it++)
	{
		int nodeorig = (*it).first;
		int nodedest = (*it).second;
		
		SideRefPatternMesh.NodeVec()[nodedest].Initialize(fRefPatternMesh.NodeVec()[nodeorig], SideRefPatternMesh);
		SideRefPatternMesh.NodeVec()[nodedest].SetNodeId(nodedest);
	}
	TPZStack<int64_t> nodeindices;
	nodeindices.Resize(gel->NSideNodes(side));
	int64_t in;
	for(in=0; in<nodeindices.NElements(); in++)
	{
		nodeindices[in] = allsidenodes[gel->SideNodeIndex(side,in)];
	}
	int matid = gel->MaterialId();
	int64_t index;
	TPZGeoEl *father = SideRefPatternMesh.CreateGeoElement(gel->Type(side),nodeindices,matid,index,1);
	int sidedim = father->Dimension();
	TPZStack<TPZGeoElSide> gelvec;
	SidePartition(gelvec, side);
	int nsub = gelvec.NElements();
	int subel;
	for(subel=0; subel<nsub; subel++)
	{
		if(gelvec[subel].Dimension() != sidedim)
		{
			continue;
		}
		nodeindices.Resize(gelvec[subel].NSideNodes());
		for(in=0; in<nodeindices.NElements(); in++)
		{
			nodeindices[in] = allsidenodes[gelvec[subel].SideNodeIndex(in)];
		}
		MElementType type = gelvec[subel].Element()->Type(gelvec[subel].Side());
		TPZGeoEl *subel = SideRefPatternMesh.CreateGeoElement(type,nodeindices,matid,index);
		subel->SetFather(father);
	}
	SideRefPatternMesh.BuildConnectivity();
}

MElementType TPZRefPattern::Type()
{
	return fRefPatternMesh.ElementVec()[0]->Type();
}

int TPZRefPattern::TPZRefPatternPermute::ClassId() const {
    return Hash("TPZRefPattern::TPZRefPatternPermute");
}

void TPZRefPattern::TPZRefPatternPermute::Read(TPZStream& buf, void* context) { //ok
    fPermute.Read(buf, context);
    fTransform.Read(buf, context);
}

void TPZRefPattern::TPZRefPatternPermute::Write(TPZStream& buf, int withclassid) const { //ok
    fPermute.Write(buf, withclassid);
    fTransform.Write(buf, withclassid);
}
