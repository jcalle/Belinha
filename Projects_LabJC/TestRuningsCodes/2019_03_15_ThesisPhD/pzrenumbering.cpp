// Generated by Together

#include "pzrenumbering.h"
#include "pzvec.h"
#include "pzerror.h"
#include "pzstack.h"



void TPZRenumbering::ConvertGraph(TPZVec<int> &elgraph, TPZVec<int> &elgraphindex, TPZVec<int> &nodegraph, TPZVec<int> &nodegraphindex){
  TPZVec<int> nelcon(fNNodes+1,0);
  int nod,last = elgraphindex[fNElements];
  for(nod = 0; nod<last; nod++) {
    nelcon[elgraph[nod]]++;
  }
  TPZVec<int> &nodtoelgraphindex = nelcon;
  for(nod=fNNodes; nod>0; nod--) nodtoelgraphindex[nod] = nodtoelgraphindex[nod-1];
  nodtoelgraphindex[0] = 0;
  for(nod=1;nod<=fNNodes;nod++) nodtoelgraphindex[nod] += nodtoelgraphindex[nod-1];
  TPZVec<int> nodtoelgraph(nodtoelgraphindex[fNNodes],-1);
  int el;
  for(el=0; el<fNElements; el++) {
    int firstnode = elgraphindex[el];
    int lastnode = elgraphindex[el+1];
    for(nod=firstnode;nod<lastnode;nod++) {
      int gnod = elgraph[nod];
      int firstel= nodtoelgraphindex[gnod];
      int lastel = nodtoelgraphindex[gnod+1];
      while(firstel<lastel && nodtoelgraph[firstel] != -1) firstel++;
      if(firstel == lastel) {
	PZError << "TPZCompMesh::ComputeConnecttoElGraph wrong data structure\n";
	continue;
      } else {
	nodtoelgraph[firstel] = el;
      }
    }
  }       
  nodegraphindex.Resize(fNNodes+1);
  nodegraphindex.Fill(0);
  int nodegraphincrement = 100;
  nodegraph.Resize(nodegraphincrement);       
  int nodegraphsize = nodegraph.NElements();
  int nextfreeindex = 0;
  for(nod=0; nod<fNNodes; nod++) {
    int firstel = nodtoelgraphindex[nod];
    int lastel = nodtoelgraphindex[nod+1];
    int firstnode = nodegraphindex[nod];
    for(el=firstel; el<lastel; el++) {
      int gel = nodtoelgraph[el];
      int firstelnode = elgraphindex[gel];
      int lastelnode = elgraphindex[gel+1];
      int elnode;
      for(elnode=firstelnode; elnode<lastelnode; elnode++) {
	int gelnode = elgraph[elnode];
	int gn = firstnode;
	if(gelnode == nod) continue;
	while(gn < nextfreeindex && nodegraph[gn] != gelnode) gn++;
	if(gn == nextfreeindex) {
	  if(nextfreeindex == nodegraphsize) {
	    nodegraph.Resize(nodegraphsize+nodegraphincrement);
	    nodegraphsize += nodegraphincrement;
	  }
	  nodegraph[gn] = gelnode;
	  nextfreeindex++;
	}
      }
    }
    nodegraphindex[nod+1] = nextfreeindex;
  }
}


TPZRenumbering::TPZRenumbering(int NElements, int NNodes){
  fNElements = NElements;
  fNNodes = NNodes;
}

int TPZRenumbering::ColorNodes(TPZVec<int> &nodegraph, TPZVec<int> &nodegraphindex, TPZVec<int> &family, TPZVec<int> &colors) {

  TPZStack<int> usedcolors;
  TPZStack<int> ncolorsbyfamily;
  if(nodegraph.NElements()-1 != family.NElements()) {
	  std::cout << "TPZRenumbering::ColorNodes inconsistent input parameters\n";
  }
  int nnodes = nodegraphindex.NElements()-1;
  colors.Resize(nnodes);
  colors.Fill(-1);
  int curfam = 0;
  int nodeshandled = 0;
  int ncolors = 0;
  while(nodeshandled < nnodes) {
    int nod;
    curfam = 0;
    usedcolors.Resize(0);
    for(nod = 0; nod < nnodes; nod++) {
      int firstnod = nodegraphindex[nod];
      int lastnod = nodegraphindex[nod+1];
      usedcolors.Fill(-1);
      int ind, nodcon;
      for(ind= firstnod; ind<lastnod; ind++) {
	nodcon = nodegraph[ind];
	if(family[nodcon] != curfam) continue;
	if(colors[nodcon] != -1) usedcolors[colors[nodcon]] = 1;
      }
      int ic;
      for(ic=0; ic<usedcolors.NElements(); ic++) if(usedcolors[ic] != 1) break;
      if(ic == usedcolors.NElements()) usedcolors.Push(1);
      colors[nod] = ic;
      nodeshandled++;
    }
    ncolorsbyfamily.Push(usedcolors.NElements());
    ncolors += usedcolors.NElements();
    curfam++;
  }
  return ncolors;
}
